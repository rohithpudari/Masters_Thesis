\startchapter{Framework}
\label{chapter:framework}

\section{Introduction}
In Chapters~\ref{chapter:idioms} and \ref{chapter:smells}, we identified that Copilot does not perform well in detecting and suggesting language idioms and best practices, 
the scope of capability for \cct{} like Copilot is uncertain. In this chapter, we try to address \textbf{RQ-1} (What are the current boundaries of code completion tools) with a taxonomy of 5 software abstraction levels to help access the current capabilities of Copilot. 

We explain each software abstraction level in the taxonomy and the capabilities required by \cct{} to satisfy the software abstraction level. 
We try to delineate where current \cct{} are currently best able to perform, and where more complex software engineering tasks overwhelm them. We use a sorting routine as an example scenario to show how a \cct{} suggestion looks like at every level of abstraction in our taxonomy.

In section~\ref{cs2design}, we try to address \textbf{RQ-2} (Given the current boundary, how far is it from suggesting design decisions?) with a discussion on the complex nature of design decisions involving many factors, making it difficult for \cct{} like Copilot detect the information from code files and suggest design decisions to satisfy the top abstraction level of our taxonomy.

\subsection{Motivation}
To center our analysis on creating a software abstraction hierarchy, we leverage an analogous concept in the more developed (but still nascent) field of autonomous driving. 
Koopman has adapted the SAE Autonomous Driving safety levels~\cite{sae} to those shown in figure~\ref{fig:koopman_pyramid}. 
The pyramid concept is derived from that of Maslow~\cite{Maslow1943}, such that addressing aspects on the top of the pyramid first require the satisfaction of aspects below. 
For example, before being able to think about system safety (such as what to do in morally ambiguous scenarios), the vehicle must first be able to navigate its environment reliably (``Basic Driving Functionality'').

We think that a similar hierarchy exists in \AISE{}. Before worrying about software architecture issues, that is, satisfying system quality attributes such as performance, \AISE{} tools need to be able to exhibit ``basic programming functionality''. This basic functionality is where most research effort is currently concentrated, such as program synthesis, \cct{}, and automated bug repair.

\begin{figure}[hbt!]
    \centering
    \includegraphics[width=.8\linewidth]{Figures/koopman_pyramid.png}
    \caption{Koopman's Autonomous Vehicle Safety Hierarchy of Needs~\cite{koopman}. SOTIF = safety of the intended function.}
    \label{fig:koopman_pyramid}
\end{figure}

\input{chapters/5/taxonomy}
\input{chapters/5/syntax}
\input{chapters/5/correctness}
\input{chapters/5/idioms}
\input{chapters/5/smells}
\input{chapters/5/design}
\input{chapters/5/cs2design}
\input{chapters/5/summary}