\startchapter{AI-driven Software Engineering}
\label{chapter:Exp}

The current approaches focus on programming-in-the-small \cite{DeRemer1976} i.e, on individual lines of code. 
Code language models have focused (effectively!) on source code as natural language~\cite{natural}.
This models the software development task as predicting the next token or series of tokens.
As Copilot's webpage says, the aim for Copilot is to produce ``safe and effective code [with] suggestions for whole lines or entire functions'' as ``your AI pair programmer''~\cite{Copilot-web}. 
Thus support from language models is currently focused on software \textit{programming}, rather than software \emph{engineering} (in-the-large). 
% \neil{wut? --D} 
% But there are areas of code suggestions that are not easily fixable or at least, not detectable efficiently before training or recommendation is required, at the time-scale of code completion (which we assume is nearly instantaneous, as evidenced by how existing autocomplete editors work.)

What might AI support for these more complex software engineering challenges require? 
We present a simple taxonomy in Figure \ref{fig:levels}, modeled on the ideas in the SAE taxonomy and Koopman's extension for self-driving vehicles (Fig. \ref{fig:koopman_pyramid}), as one way of thinking about this question. 

\input{chapters/4/taxonomy}
\input{chapters/4/idioms}
\input{chapters/4/practices}
\input{chapters/4/smells}
\input{chapters/4/summary}